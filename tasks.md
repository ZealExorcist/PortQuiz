Task List for Building a Security+ Ports & Protocols Quiz App
Planning and Initial Setup
Define the app’s scope and features. Clarify that the app will quiz users on common ports and protocols for the CompTIA Security+ exam. List required features: two quiz modes (Fill-in-the-Blank and Multiple Choice), each supporting two variations (identify protocol from port, and identify port from protocol), a Memory Match game mode, local score tracking, single- and two-player modes, and optional hints/mnemonics. Sketch the main user flows (e.g. mode selection, question flow, game flow) to ensure all features are covered and to guide design.
Choose technology stack details. Confirm the use of Python with Flask for the backend and vanilla JavaScript/HTML/CSS for the frontend. Decide on any additional libraries or frameworks (e.g. Bootstrap for CSS, or a JS library for UI components) if desired for faster development. Ensure compatibility of Flask with any front-end setup (e.g. templates).
Plan the project structure. Outline a file/directory organization before coding. For example: a top-level project folder containing app/ (Flask application), static/ (JS, CSS, images), templates/ (HTML templates), and possibly data/ or questions/ for storing quiz data (JSON or CSV). Plan how pages will link (e.g. a homepage to choose modes).
Outline development milestones. Break the project into phases: environment setup, creating question data, building the backend (routes, API), designing the frontend (UI layout), implementing each mode, adding multiplayer/score features, integrating hints, testing, and deployment. This high-level plan will guide the ordered tasks below.
Environment and Version Control Setup
Set up Python environment. Install Python 3.x on the development machine. Create and activate a virtual environment (using venv or virtualenv) to manage dependencies. Install Flask (pip install Flask) and any other needed packages (e.g. Flask-Cors if using AJAX).
Initialize the project repository. Use Git for version control from the start. Run git init in the project root. Create a GitHub (or similar) repository and connect it. Commit the initial state (empty folders, README file, .gitignore for Python and environment files).
Organize initial file structure. Create folders and files:
app/ directory containing __init__.py (Flask app factory or config) and main Python scripts (e.g. routes.py or views.py).
app/templates/ for HTML files (e.g. base.html, index.html, etc.).
app/static/ with subfolders css/, js/, and images/. Add empty main.css and main.js or relevant files.
If keeping data separate, create a data/ directory (or within app/) to store the quiz question data (e.g. JSON or CSV).
Initial commit. After creating this structure and any boilerplate files (like requirements.txt with Flask listed), make a commit in Git. This serves as a safe base before further coding.
Data and Content Creation
Compile a list of ports and protocols. Gather a comprehensive list of common ports and their corresponding protocols relevant to Security+ (e.g. HTTP – 80, HTTPS – 443, FTP – 21, SSH – 22, etc.). Ensure both directions: protocol-to-port and port-to-protocol pairs.
Include optional hints/mnemonics. For each port/protocol pair, write a short hint or mnemonic to aid learning (e.g. “21: FTP = File Transfer Protocol – think of ‘Funny Tiger Painting’ as a memory aid”). Store these hints alongside the question data.
Choose data storage format. Save the questions in a structured format. A good approach is JSON or CSV in the data/ folder. For example, a JSON array where each element has fields: port, protocol, hint. Example entry: {"port": "21", "protocol": "FTP", "hint": "File Transfer Protocol (FTP) on port 21"}. Alternatively, you could use separate lists for port-to-protocol and protocol-to-port questions, but a unified format is simpler.
Validate and extend the dataset. Ensure there are enough entries to support each mode (especially multiple-choice, which needs distractors). Aim for a sizable list (20–30+ entries) so the quizzes have variety. Check the data for accuracy. Commit the question data file(s) to the repository.
Backend Development (Flask)
Configure the Flask app. In app/__init__.py, set up the Flask application object. Configure static and template folders if needed. Create app/routes.py (or views.py) for route definitions. Ensure run.py or app.py in project root starts the Flask server (e.g. from app import app; app.run(debug=True)).
Create basic routes and templates. Define a route for the home page (e.g. /) that renders an index.html template with links or buttons to select quiz modes (Fill-in, MCQ, Memory). Also create separate routes for each mode (e.g. /fill-blank, /mcq, /memory) that serve respective templates. At this point, the templates can be placeholders (e.g. “Under construction”).
Set up static file serving. Verify that Flask is correctly serving the static/ folder (Flask does this by default at /static/). Include CSS and JS files in the HTML templates with the proper path (e.g. <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">).
Prepare API endpoints for question data (optional). Decide if you want to fetch question data via HTTP. For dynamic loading, implement API routes like /api/questions that return JSON data for quizzes. Alternatively, you can embed the data in the frontend via a JSON file in static/. If using an endpoint, create a route that reads the data file and returns JSON (flask.jsonify).
Integrate backend with frontend (if needed). Plan how the frontend will get question data. If using Jinja2, you could pass question data to templates. More likely, use JavaScript to fetch the JSON data from the server (either a static file or Flask endpoint).
Test basic Flask server. Run the server locally and ensure that visiting each route serves the correct template and that static assets (CSS/JS) load. Fix any routing or asset issues. Commit changes.
Frontend Structure and Navigation
Design the main layout. In templates/base.html, create a base HTML structure (header, footer, navigation) using Jinja2 if needed. Include references to CSS and JS. This base template will be extended by other pages. For example, a navbar with links: Home, Fill-in Quiz, MCQ Quiz, Memory Match, Scoreboard.
Develop the homepage. In templates/index.html (extending base.html), add buttons or cards for each mode (Fill-in-Blank, Multiple Choice, Memory Match). Also include options to select single-player or two-player mode before starting. Ensure navigation is clear. Use placeholder text or layout; final styling comes later.
Set up frontend script files. In static/js/, create separate JS files for each mode (e.g. fillblank.js, mcq.js, memory.js) plus a main.js for common utilities. Link them in the corresponding HTML templates. Similarly, set up CSS files: a global main.css and any additional CSS per mode if needed.
Link pages together. Ensure that when a user clicks on “Fill-in-Blank” or “MCQ” on the homepage, the app navigates to the correct route/page. You can use Flask url_for in Jinja templates to link to the routes defined. Verify navigation works and pages load.
Fill-in-the-Blank Quiz Mode
Set up the Fill-in template. In templates/fill_blank.html (extending base.html), create the HTML structure: a question display area (e.g. “Port: ___, Protocol: ___?”), an input field for the user’s answer, and buttons for “Submit Answer” and “Next Question.” Also include a “Hint” button and a placeholder for feedback.
Load question data in JS. In fillblank.js, fetch or import the port/protocol data (e.g. using fetch('/static/data/questions.json') or via a Flask API). Store the data in a JS array. Add logic to shuffle or select questions randomly or sequentially.
Implement question variation. Provide a toggle or dropdown in the UI to switch between “Name the Protocol” (given a port) and “Name the Port” (given a protocol). Based on the selection, display the appropriate prompt (for example, if “protocol” is chosen, show “Port 443” and ask for “Protocol”; if “port” is chosen, show “HTTPS” and ask for “Port number”).
Answer submission and validation. Add an event listener to the Submit button. When clicked, check the input against the correct answer (case-insensitive text or numeric). If correct, display positive feedback; if not, indicate incorrect and optionally allow retry. In either case, reveal the correct answer after submission.
Update score in localStorage. Each time a question is answered, update the user’s score in localStorage (e.g. increment “correct” or “attempts” counters). Store separate scores for single vs. two-player modes if relevant. Ensure the data persists by writing JSON or simple key-value pairs in localStorage.
Provide next-question flow. After answering, allow the user to proceed to the next question (either automatically after a delay or via a Next button). When questions are exhausted or a set count is reached, display a summary (e.g. “Quiz complete – You got X out of Y right”).
Display hints. If the user clicks the “Hint” button (or after an incorrect answer), show the hint/mnemonic retrieved from the data for that question. Ensure the hint is helpful and doesn’t immediately reveal the answer (for example, rephrase it or reveal partial info).
Test the flow. Run through several questions in both variations (“protocol from port” and “port from protocol”) to check the logic. Make sure input validation, scoring, and hint display work correctly. Fix any issues (e.g. handling of numeric vs. string comparisons).
Multiple Choice Quiz Mode
Set up the MCQ template. In templates/mcq.html, design the page: display either a port or protocol as the question prompt (like in fill-blank), and list four answer choices (radio buttons or clickable buttons). Include “Submit” and “Next Question” buttons and a hint option.
Prepare multiple-choice data. In mcq.js, use the same question dataset. For each question, randomly select the correct answer plus 3 distractors. For “Name the Protocol” mode, show a port and provide one correct protocol and three incorrect protocols; vice versa for “Name the Port.” Ensure distractors are plausible (randomly pick other protocols/ports from the data).
Display randomized options. Shuffle the four choices so the correct answer isn’t always in the same position. Render them in the HTML (e.g. <input type="radio"> with labels, or buttons with event handlers).
Handle answer selection. On Submit, check which choice was selected. Compare against the correct answer. Display immediate feedback: highlight the chosen answer green if correct or red if wrong, and indicate the right answer. Update the score accordingly (increment correct/incorrect).
Score tracking. As with Fill-in-Blank, store the outcome of each question in localStorage. Track total correct answers out of total questions attempted. If in two-player mode, alternate players or give each player their own score variables (see multiplayer section).
Next question logic. After feedback, allow the user to proceed to the next question. Continue until the quiz is complete, then show final results (score summary). Provide a reset or retry option.
Include hints (optional). If using hints here, either show a “Hint” button similar to fill-in mode or automatically provide a clue. Ensure hint content still makes sense (e.g. “The protocol is an encrypted version of HTTP”).
Verify functionality. Test the MCQ mode thoroughly: check that choices don’t repeat across questions (unless intended), that scoring updates properly, and that switching between variations (port-to-protocol vs protocol-to-port) works seamlessly.
Memory Match Game Mode
Design the Memory Match board. In templates/memory.html, create a container for the game board (a grid of face-down cards). Each card will hide either a port or a protocol. Ensure the grid layout can adjust (e.g. use CSS grid or flexbox). Add a place to display player turn or score, and a “Restart Game” button.
Prepare matching pairs data. In memory.js, take the list of port-protocol pairs from the dataset. Create a list of card objects, where each pair generates two cards: one showing the port and one showing the protocol. For example, pair (80, HTTP) yields a card “80” and a card “HTTP” which match.
Shuffle and display cards. Randomize the combined list of cards and create HTML elements for each (e.g. <div class="card" data-value="80">). Initially display them face-down (blank or with a back image). Attach click event handlers to flip cards.
Implement match logic. When a card is clicked, flip it to reveal the value. If two cards are face-up, compare them: if one’s value is a protocol and the other is its port (matching pair), keep them revealed/removed and increase the current player’s score. If not a match, flip them back after a short delay. Block further clicks during the checking delay.
Handle player turns. If single-player, just continue. For two-player mode, alternate turns: after a mismatch (or after a match, depending on game rules) switch the current player. Display which player’s turn it is and each player’s score. Store both players’ scores in localStorage so they persist if the page reloads mid-game.
Game end and scoring. The game ends when all pairs are found. Display the final scores for each player and declare the winner (or tie). Offer an option to restart the game. Update localStorage to record final scores or number of turns taken if desired.
Include hints if applicable. Memory games don’t usually use hints, but you could add an initial “Preview” period where all cards flip briefly at the start. Otherwise, ensure the user can easily restart if the game is too hard.
Test memory gameplay. Play through the Memory mode multiple times. Ensure the cards flip correctly, matches are detected, and scores update. Verify turn-switching in two-player mode. Check that restarting clears the board and resets scores.
Scoring, Multiplayer, and Local Storage
Implement single vs. two-player selection. In a common settings area or before starting a quiz/game, let the user choose single-player or two-player mode. Store this choice (in session or localStorage) and adjust the logic accordingly (e.g., two score trackers).
Manage turn-taking for two players. In quiz modes, decide how two players interact. One approach: players alternate answering questions (Player 1 answers Q1, Player 2 answers Q2, etc.), or compete by answering the same questions in turns. Clearly indicate whose turn it is (e.g. “Player 1’s turn”). In Memory mode, alternate after each attempt as noted above. Reset current player on a new game.
Use localStorage for scores and persistence. Define keys in localStorage for storing progress and scores, such as "player1_score", "player2_score", "total_questions", etc. Update these values on each correct answer or successful match. This way, if the page is accidentally refreshed, the scores can be reloaded and the game can continue without losing progress.
Display scoreboards. On each page (or in a fixed UI element), show the current score(s). For quizzes, you might show “Correct / Total” and separate columns for each player. For Memory, show “Pairs found” per player. Update the display dynamically as scores change.
Implement a reset/clear function. Provide a way for the user to reset the scores (especially if switching modes or after finishing a game). Clearing relevant localStorage entries on reset ensures a fresh start for new sessions.
Persist completion records (optional). If desired, you could record high scores or past results in localStorage. For example, store an array of past quiz scores (timestamp and points). This is an advanced step and can be considered for added polish.
Hints and Mnemonics Integration
Link hints to questions. In both quiz modes, use the hint text stored in the data for each question. Include a “Show Hint” button in the UI. When clicked, display the mnemonic or hint associated with that question. This helps learners make connections but doesn’t immediately give away the exact answer.
Reveal hints conditionally. Optionally, configure hints to appear only after the first incorrect attempt, or after a time delay. This encourages the user to try on their own first. Implement this logic in the JS handling the question flow.
Format hints for readability. In CSS, style the hint text so it’s clearly distinguishable (e.g. italic or a different color). Ensure it doesn’t break the layout. If a hint is long, consider a tooltip or a collapsible section to keep the UI clean.
Test hint functionality. Verify that the correct hint appears for each question variation and that clicking the button shows/hides the hint as expected. Check that hint usage does not interfere with scoring (e.g. don’t count showing a hint as a correct answer).
UI Design and Styling
Develop a consistent visual theme. Choose a color scheme and fonts appropriate for an educational quiz app (e.g. calm blues/greens). Apply these in main.css. Consider using a CSS framework like Bootstrap or Tailwind for rapid, responsive design, but custom CSS is also fine. Ensure all pages share a consistent header/footer style.
Make the layout responsive. Use flexible containers, percentage widths, or CSS Grid/Flexbox so the app works on different screen sizes (desktop, tablet, mobile). Test by resizing the browser. Adjust elements (buttons, text fields, game board) to remain usable on small screens.
Enhance user feedback. Add hover effects on buttons, highlight the current question or player’s name, and disable buttons when not applicable (e.g. disable Submit after clicking until next question loads). In the Memory game, add a flip animation (CSS transition) when cards are clicked.
Ensure accessibility. Use semantic HTML (e.g. <button>, <label>, <input>) and ARIA labels if necessary. Provide alt text for any images/icons. Ensure color choices have enough contrast. Users should be able to tab through inputs and activate with keyboard.
Polish visual elements. Add a logo or title text on the home screen (“Security+ Ports & Protocols Quiz”). Use icons (from FontAwesome or similar) for hint, score, etc. Make sure text is centered or formatted neatly. Fine-tune padding and margins for a clean appearance.
Validate UI on multiple browsers. Open the app in Chrome, Firefox, Edge, and a mobile browser to check styling consistency. Fix any CSS quirks (e.g. vendor prefixes, unsupported features).
Testing, Debugging, and Polishing
Perform functional testing. Go through every feature as a user would. Play each quiz mode in single- and two-player, test scoring updates, hint display, and completion screens. Ensure there are no console errors. Verify that incorrect inputs (e.g. entering letters when a number is expected) are handled gracefully (validation or clear messages).
Test data integrity. Ensure questions do not repeat too often (randomization works) and that correct answers align with the prompts. Check edge cases like the last question in the quiz, or a full reset after finishing a game.
Fix bugs and refine logic. Address any issues found during testing: incorrect score tallying, UI elements not updating, or navigation problems. Refine the code for clarity and efficiency (e.g. avoid duplicate code between quiz modes, use functions/modules).
Check localStorage usage. Confirm that scores persist as intended. Refresh pages mid-quiz to ensure data reloads properly. Also test clearing storage or playing the quiz again to start fresh.
User experience polishing. Add transitions or delays if needed to make the app feel smooth (e.g. short delay after showing correct answer before moving on). Make sure feedback messages are friendly and instructive. Possibly add a “back to home” button on each page.
Write documentation and comments. In the code, comment complex logic (e.g. memory match comparisons). In the project repo, update README.md with instructions on running the app locally, overview of features, and any deployment notes. Include screenshot images if desired for clarity.
Version Control and Deployment
Commit frequently. Throughout development, make Git commits for each completed task or milestone (e.g. “Implement fill-in-the-blank logic” or “Add localStorage score tracking”). Use clear commit messages. This helps track progress and roll back if needed.
Create deployment configuration. If deploying to a Flask-capable host (like Heroku), add a requirements.txt file (pip freeze > requirements.txt), and a Procfile (e.g. web: gunicorn app:app if using Gunicorn). Ensure app/__init__.py exposes the Flask app object. If using Heroku, also include a runtime.txt for Python version.
Choose a hosting platform. For a fully Flask app, Heroku, PythonAnywhere, or AWS Elastic Beanstalk are good options. For a primarily static front end (if you embed data and don’t need a Flask server at runtime), GitHub Pages is possible by building the final site into static files (though dynamic score tracking would still need JS and localStorage, which GitHub Pages can serve).
Deploy to staging. Push the code to GitHub. Connect the repository to the chosen host (e.g. link GitHub to Heroku). Deploy and test the live site: make sure routes work, static assets load, and localStorage functions (remember, localStorage works client-side anywhere). Fix any deployment-specific bugs (e.g. incorrect file paths).
Perform final testing on the deployed app. Go through all modes on the live version. Ensure any relative URLs still work. Check for missing resources (like JS or CSS not found). Test on the actual domain/URL to catch issues not present in local dev.
Launch and monitor. Once satisfied, finalize the deployment. Share the link or push to main branch for GitHub Pages. Optionally set up analytics or monitoring (for a simple app, this may not be needed). Keep the repository updated with any bug fixes post-launch.
Future enhancements (post-launch, optional). Note ideas for future work, like adding timed quizzes, user login for progress saving (beyond localStorage), more question categories, or improved graphics. These are beyond initial scope but good to document.
Each of these steps should be carried out in order, with testing at the end of each major section to ensure stability. By following this comprehensive task list, a solo developer can systematically build, refine, and deploy the web-based learning app with all the required features.